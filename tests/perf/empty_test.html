<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>

    <head>
        <title>
            CubicVR.js Performance Test Runner
        </title>
        <script src="../../CubicVR.js" type="text/javascript">
        </script>
    </head>

    <body>
        <h1>CubicVR.js Performance Test Runner</h1>
        <p>To start the tests click Start.  Each test is run in order (downloaded from the server).  Tests are run for based on the given number of iterations (specified below), and the time is recorded.</p>

        <h3>Settings</h3>
        <div>Run basic  Tests: &nbsp;
            Frames Per Test: <input type="text" size="4" id="iterations" onchange="updateIterations();"/>&nbsp;
            <input onclick="webGLStart();" type="button" value="Start"/><span id="testCount"></span></div>

        <h3>Results</h3>
        <div id="total"></div>
        <div id="results" style="margin: 5px; padding-top: 10px;"></div>
        <div style='font-family:Arial;font-size:14px;font-weight:bold'>Time Taken: <span id='timeTaken'>...</span></div>
        <div style='font-family:Arial;font-size:14px;font-weight:bold'>FPS: <span id='fpsText'>...</span></div>
        <p id='frames'>Time taken.</p>

        <script type='text/javascript'>
            var timerMilliseconds;
            var timerSeconds = 0;
            var timerLastSeconds = 0;
            var frameCounter = 0;
            var frames = 0;
            var camera;
            var boxObject;
            var scene;
            var drawScene;
            var frames = 0;
            var results = document.getElementById('results');
            var gl;
            var canvas;
            var xp = 0;
            var boxMesh;
            var total = document.getElementById('total');
            total.innerHTML = '';
            
            // Tolerance values and kernel for blur
            var iterationCount = 500;
            document.getElementById('iterations').value = iterationCount;
            
            function updateIterations() {
                var newIterationCount = document.getElementById('iterations').value;
                if (newIterationCount) {
                    iterationCount = parseInt(newIterationCount, 10);
                }
            }
            
            function webGLStart() {
                var buildCanvas = function(id, w, h) {
                    var c = document.createElement('canvas');
                    c.id = id;
                    c.width = w;
                    c.height = h;
                    c.className = "test";
                    return c;
                };
                // by default generate a full screen canvas with automatic resize
                canvas = buildCanvas('myCanvas',400,400);
                results.appendChild(canvas);
                gl = CubicVR.init(canvas);
                //gl = CubicVR.init('myCanvas');
                //var canvas = document.getElementById("myCanvas");
                //initGL(canvas);
                //canvas = CubicVR.getCanvas();

                if (!gl) {
                    alert("Sorry, no WebGL support.");
                    return;
                };
                
                // Create a material for the mesh
                var boxMaterial = new CubicVR.Material({
                    textures: {
                        color: new CubicVR.Texture("../images/6583-diffuse.jpg"),
                        bump: new CubicVR.Texture("../images/6583-bump.jpg")
                    }
                });

                // Add a box to mesh, size 1.0, apply material and UV parameters
                boxMesh = CubicVR.primitives.box({
                    size: 1.0,
                    material: boxMaterial,
                    uvmapper: {
                        projectionMode: CubicVR.enums.uv.projection.CUBIC,
                        scale: [1, 1, 1]
                    }
                });

                // triangulate and buffer object to GPU, remove unused data
                boxMesh.prepare();
                // New scene with our canvas dimensions and default camera with FOV 80
                scene = new CubicVR.Scene(canvas.width, canvas.height, 80);

                // SceneObject container for the mesh
                boxObject = new CubicVR.SceneObject(boxMesh);

                // Add SceneObject containing the mesh to the scene
                scene.bindSceneObject(boxObject);

                // set initial camera position and target
                scene.camera.position = [1, 1, 1];
                scene.camera.target = [0, 0, 0];
                
                /*camera = new CubicVR.Camera(canvas.width,canvas.height,60);
                var camPos = [1,1,1];
                var camTarget = [0,0,0];

                camera.position = camPos;
                camera.target = camTarget;
                
                gl.clearColor(0.0, 0.0, 0.0, 1.0);

                gl.clearDepth(1.0);

                gl.enable(gl.DEPTH_TEST);
                gl.depthFunc(gl.LEQUAL);*/
                
                //setInterval(drawScene, 15);
                
                 // New scene with our canvas dimensions and default camera with FOV 80
                var scene = new CubicVR.Scene(canvas.width, canvas.height, 80);

                // SceneObject container for the mesh
                var boxObject = new CubicVR.SceneObject(boxMesh);

                // Add SceneObject containing the mesh to the scene
                scene.bindSceneObject(boxObject);

                // set initial camera position and target
                scene.camera.position = [1, 1, 1];
                scene.camera.target = [0, 0, 0];
                
                // initialize a mouse view controller
                mvc = new CubicVR.MouseViewController(canvas, scene.camera);
                
                // Get the start time
                /*var startTime = (new Date).getTime();
                var endTime = 0;*/

                // Start our main drawing loop, it provides a timer and the gl context as parameters
                CubicVR.MainLoop(function(timer, gl) {
                    scene.render();
                    document.getElementById('frames').innerHTML = frames;
                    ++frames;
                    if (frames===iterationCount) {
                        document.getElementById('timeTaken').innerHTML = timer.getTotalMilliseconds() + "ms";
                        CubicVR.MainLoop(null);
                        //endTime = (new Date).getTime();
                        return;
                    }
                    if (!timerMilliseconds)
                    {
                        timerMilliseconds = (new Date()).getTime();
                        return;
                    }
			
                    frameCounter++;
				
                    var newTimerMilliseconds = (new Date()).getTime();
				
                    timerLastSeconds = (newTimerMilliseconds-timerMilliseconds)/1000.0;

                    if (timerLastSeconds > (1/10)) timerLastSeconds = (1/10);

                    timerSeconds += timerLastSeconds;
                    timerMilliseconds = newTimerMilliseconds;

                    if (frameCounter%30==0)
                    {
                        fpsStr = ""+frameCounter/timerSeconds;
                        document.getElementById('fpsText').innerHTML=fpsStr.substring(0,6);
                        frameCounter=0;
                        timerSeconds=0;
                    }
                });
                
//                document.getElementById('timeTaken').innerHTML = (endTime - startTime) + "ms";
            }
            
            /*drawScene = function() {
                if (!timerMilliseconds)
                {
                    timerMilliseconds = (new Date()).getTime();
                    return;
                }
			
                frameCounter++;
				
                var newTimerMilliseconds = (new Date()).getTime();
				
                timerLastSeconds = (newTimerMilliseconds-timerMilliseconds)/1000.0;

                if (timerLastSeconds > (1/10)) timerLastSeconds = (1/10);

                timerSeconds += timerLastSeconds;
                timerMilliseconds = newTimerMilliseconds;

                if (frameCounter%30==0)
                {
                    fpsStr = ""+frameCounter/timerSeconds;
                    document.getElementById('fpsText').innerHTML=fpsStr.substring(0,6);
                    frameCounter=0;
                    timerSeconds=0;
                }

                /*xp += 0.5*timerLastSeconds;

                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                camera.position = CubicVR.vec3.trackTarget(camera.position,camera.target,0.05,camDist);
                camera.lookat(camera.target);
                
                var sz = 1.5;
                var transMat = new CubicVR.Transform();
				
                for (var i = -sz; i <= sz; i++)
                {
                    for (var j = -sz; j <= sz; j++)
                    {
                        for (var k = -sz; k <= sz; k++)
                        {
                            t = transMat.clearStack().pushMatrix().translate(i*5,j*5,k*5).pushMatrix().rotate([i*50+xp*spd,j*50+xp*spd2,k*50+xp*4.0]).pushMatrix().scale(7,7,7).getResult();
                            CubicVR.renderObject(boxMesh,camera,t);
                        }
                    }					
                }
                // Start our main drawing loop, it provides a timer and the gl context as parameters
                CubicVR.MainLoop(function(timer, gl) {
                    scene.render();
                    //document.getElementById('test').innerHTML=timer.getSeconds();
                });
                document.getElementById('test3').innerHTML = frames;
                ++frames;
            };*/
        </script>
    </body>
</html>
